### Redis 的数据类型？

Redis 支持五种数据类型：string（字符串），hash（哈希），list（列表），set（集合）及 zsetsorted set：有序集合)。



### 使用 Redis 有哪些好处？
1. 速度快，因为数据存在内存中，类似于 HashMap，HashMap 的优势就是查找和操作的时间复杂度都是 O1)
2. 支持丰富数据类型，支持 string，list，set，Zset，hash 等
3. 支持事务，操作都是原子性，所谓的原子性就是对数据的更改要么全部执行，要么全部不执行
4. 丰富的特性：可用于缓存，消息，按 key 设置过期时间，过期后将会自动删除

### Redis 相比 Memcached 有哪些优势？
1. Memcached 所有的值均是简单的字符串，redis 作为其替代者，支持更多数据类型
2. Redis 的速度比 Memcached 快很多
3. Redis 可以持久化数据


### Redis 是单进程单线程的？
Redis 是单进程单线程的，redis 利用队列技术将并发访问变为串行访问，消除了传统数据库串行控制的开销。

### 一个字符串类型的值能存储最大容量是多少？  
512M

### Redis 的持久化机制是什么？各自的优缺点？

Redis 提供两种持久化机制 RDB 和 AOF 机制：
#### RDBRedis DataBase)持久化方式：
快照的方式半持久化模式) 记录 Redis 数据库的所有键值对, 在某个时间点将数据写入一个临时文件，持久化结束后，用这个临时文件替换上次持久化的文件，达到数据恢复。

**优点：**
1. 一个文件 dump.rdb，方便持久化，容灾性好。
2. 性能最大化，使用单独子进程来进行持久化，主进程不会进行任何 IO操作，保证了 Redis 的高性能。
3. 相对于数据集大时，比 AOF 的启动效率更高。

**缺点：**
1. 数据安全性低。（RDB 是间隔一段时间进行持久化，如果持久化之间 Redis 发生故障，会发生数据丢失。所以这种方式更适合数据要求不严谨的时候。）

#### AOFAppend-only file)持久化方式：
是指所有的命令行记录以 Redis 命令请求协议的格式完全持久化存储)保存为aof 文件。

**优点：**

 1. 数据安全，aof 持久化可以配置 appendfsync 属性，有 always，每进行一次命令操作就记录到 aof 文件中一次。
 2. 通过 append 模式写文件，即使中途服务器宕机，可以通过 redis-check-aof 工具解决数据一致性问题。
 3. AOF 机制的 rewrite 模式。AOF 文件没被 rewrite 之前（文件过大时会对命令进行合并重写），可以删除其中的某些命令（比如误操作的flushall）)

**缺点：**
 1. AOF 文件比 RDB 文件大，且恢复速度慢。
2. 据集大的时候，比 rdb 启动效率低。


### Redis 过期键的删除策略？

1. 定时删除:在设置键的过期时间的同时，创建一个定时器 timer). 让定时器在键的过期时间来临时，立即执行对键的删除操作。
2. 惰性删除:放任键过期不管，但是每次从键空间中获取键时，都检查取得的键是否过期，如果过期的话，就删除该键;如果没有过期，就返回该键。
3. 定期删除:每隔一段时间程序就对数据库进行一次检查，删除里面的过期键。至于要删除多少过期键，以及要检查多少个数据库，则由算法决定

### Redis 最适合的场景？

1. 会话缓存（Session Cache）:  用 Redis 缓存会话比其他存储（如 Memcached）的优势在于：Redis 提供持久化。
2. 全页缓存（FPC）
3. 队列： 例如，Celery 有一个后台就是使用 Redis 作为 broker。
4. 排行榜/计数器：  递增或递减的操作， 集合（Set）和有序集合（Sorted Set）
5. 发布/订阅

### Redis 的回收策略（淘汰策略）?

### MySQL 里有 2000w 数据，Redis 中只存 20w 的数据，如何保证 Redis 中的数据都是热点数据？Redis 内存数据集大小上升到一定大小的时候，就会施行数据淘汰策略。

6 种数据淘汰策略：

1. volatile-lru：从已设置过期时间的数据集（server.db[i].expires）中挑选最近最少使用的数据淘汰
2. volatile-ttl：从已设置过期时间的数据集中挑选将要过期的数据淘汰
3. volatile-random：从已设置过期时间的数据集中任意选择数据淘汰
4. allkeys-lru：从数据集（server.db[i].dict）中挑选最近最少使用的数据淘汰
5. allkeys-random：从数据集中任意选择数据淘汰
6. no-enviction（驱逐）：禁止驱逐数据


### 假如 Redis 里面有 1 亿个 key，其中有 10w 个 key 是以某个固定的已知的前缀开头的，如果将它们全部找出来？
使用 keys 指令可以扫出指定模式的 key 列表。

对方接着追问：如果这个 Redis 正在给线上的业务提供服务，那使用 keys 指令会有什么问题？
这个时候你要回答 Redis 关键的一个特性：Redis 的单线程的。keys 指令会导致线程阻塞一段时间，线上服务会停顿，直到指令执行完毕，服务才能恢复。这个时候可以使用 scan 指令，scan 指令可以无阻塞的提取出指定模式的, key 列表，但是会有一定的重复概率，在客户端做一次去重就可以了，但是整体所花费的时间会比直接用 keys 指令长。


### 如果有大量的 key 需要设置同一时间过期，一般需要注意什么？

如果大量的 key 过期时间设置的过于集中，到过期的那个时间点，Redis 可能会出现短暂的卡顿现象。一般需要在时间上加一个随机值，使得过期时间 分散一些。


### 使用过 Redis 做异步队列么，你是怎么用的？

一般使用 list 结构作为队列，rpush 生产消息，lpop 消费消息。当 lpop 没有消息的时候，要适当 sleep 一会再重试。

如果对方追问可不可以不 用 sleep 呢？
	list 还有个指令叫 blpop，在没有消息的时候，它会阻塞住直 到消息到来。

如果对方追问能不能生产一次消费多次呢？
	使用 pub/sub 主题订 阅者模式，可以实现 1:N 的消息队列。

如果对方追问 pub/sub 有什么缺点？
	在消费者下线的情况下，生产的消息会丢失，得使用专业的消息队列如RabbitMQ 等。

如果对方追问 Redis 如何实现延时队列？
	使用 sortedset，拿时间戳作为 score，消息内容作为 key 调用 zadd 来生产消息，消费者用zrangebyscore 指令获取 N 秒之前的数据轮询进行处理。


### 使用过 Redis 分布式锁么，它是什么回事

先拿 setnx 来争抢锁，抢到之后，再用 expire 给锁加一个过期时间防止锁忘记了释放。

这时候对方会告诉你说你回答得不错，然后接着问如果在 setnx 之后执行expire 之前进程意外 crash 或者要重启维护了，那会怎么样？

这时候你要给予惊讶的反馈：唉，是喔，这个锁就永远得不到释放了。紧接着你需要抓一抓自己得脑袋，故作思考片刻，好像接下来的结果是你主动思考出来的，然后回答：我记得 set 指令有非常复杂的参数，这个应该是可以同时把 setnx 和expire 合成一条指令来用的！
对方这时会显露笑容，心里开始默念：摁，这小子还不错。